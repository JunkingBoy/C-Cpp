/**
 * @Author: Lucifer
 * @Date: 5/13/2023, 12:04:02 AM
 * @LastEditors: Lucifer
 * @LastEditTime: 5/13/2023, 12:04:02 AM
 * Description: 对多维数组的指针的使用,注意在发生指针加减的时候多维数组的指针的移动
 * Copyright: Copyright (©)}) 2023 Your Name. All rights reserved.
 */
# include<stdio.h>

int main(void)
{
    int zip[4][2] = 
    {
        {2, 4},
        {6, 8},
        {1, 3},
        {5, 7}
    };

    printf("zip = %p, zip + 1 = %p.\n", zip, zip + 1); // 这是最外层数组的两个元素之间的距离,是两个int类型元素的字节大小
    printf("zip[0] = %p, zip[0] + 1 = %p.\n", zip[0], zip[0] + 1); // 这是内层数组的两个元素之间的距离,是一个int类型的大小
    printf("*zip = %p, *zip + 1 = %p.\n", *zip, *zip + 1); // 因为是二维数组,所以最外层的解引用得到的结果是指向内层数组的指针
    printf("zip[0][0] = %d.\n", zip[0][0]);
    printf(" *zip[0] = %d.\n", *zip[0]); // 这是解引用了某个地址,所以得到的是具体的数组值zip代表的是指向内层数组的内层数组当中的元素的首元素的指针
    printf("   **zip = %d.\n", **zip); // 双解引用,得到的是内层第一个数组的第一个元素
    printf("    zip[2][1] = %d.\n", zip[2][1]); // 1
    printf("     *(*zip + 2) + 1 = %d.\n", *(*zip + 2) + 1); // 7关键解读
    printf("       **(zip + 1) + 1 = %d.\n", **(zip + 1) + 1); // 这个结果也是7但是指针在外层数组上移动 
    /**
     * 最后一个Printf的结果是7
     * 第一层*zip得到的是内层数组的第一个元素的地址,
     * 该地址+2对于内层数组来说已经越界了,但是对于外层数组来说并没有,该地址+2指针会指向外层数组下一层数组的头元素上,
     * 解析该地址得到的是6 ---> 说明这个移动并非是在外层数组上移动,如果是的话那么解析该地址应该得到的还是一个地址
     * 6+1得7
    */
    printf("查看两个解引用的内存地址: *(*zip + 2) = %p, **(zip + 1) = %p.\n", &(*(*zip + 2)), &(**(zip + 1))); // 两者内存地址一样,说明两种移动方式都可以指向该元素

    getchar();

    return 0;
}